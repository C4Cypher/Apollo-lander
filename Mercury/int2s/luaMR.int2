:- module luaMR.
:- interface.
:- include_module (luaMR.api).
:- include_module (luaMR.state).
:- use_module bool.
:- use_module float.
:- use_module int.
:- use_module io.
:- use_module list.
:- use_module string.
:- use_module univ.
:- type c_function.
:- type error_type
    --->    no_error 
    ;       runtime_error 
    ;       syntax_error 
    ;       memory_error 
    ;       unhandled_error .
:- type index.
:- type ls == luaMR.lua_state.
:- type lua.
:- type lua_error
    --->    lua_error(luaMR.error_type, string).
:- type lua_state.
:- type lua_type
    --->    none 
    ;       nil_type 
    ;       number_type 
    ;       boolean_type 
    ;       string_type 
    ;       lightuserdata_type 
    ;       function_type 
    ;       table_type 
    ;       thread_type 
    ;       userdata_type .
:- type mr_func == (impure ((func luaMR.lua) = int)).
:- type nil
    --->    nil .
:- type ref.
:- type value
    --->    nil(luaMR.nil)
    ;       number(float)
    ;       integer(int)
    ;       boolean(bool.bool)
    ;       string(string)
    ;       lightuserdata(builtin.c_pointer)
    ;       thread(luaMR.lua)
    ;       c_function(luaMR.c_function)
    ;       var(luaMR.var)
    ;       userdata(univ.univ)
    ;       lua_error(luaMR.lua_error).
:- type values == list.list(luaMR.value).
:- type var
    --->    local(luaMR.index)
    ;       index(luaMR.value, luaMR.var)
    ;       meta(luaMR.var)
    ;       ref(luaMR.ref)
    ;       global(string)
    ;       invalid(string).
:- type vars == list.list(luaMR.var).
:- inst (mr_func) == (func((builtin.in)) = (builtin.out) is det).
:- mode (li) == builtin.in(bound(lua)).
:- mode (lo) == builtin.out(bound(lua)).
:- mode (mri) == builtin.in((luaMR.mr_func)).
:- mode (mro) == builtin.out((luaMR.mr_func)).
:- type_representation(error_type, du_repn(enum("no_error", "runtime_error", ["syntax_error", "memory_error", "unhandled_error"],  c_j_cs_e(foreign_enum(["0", "LUA_ERRRUN", "LUA_ERRSYNTAX", "LUA_ERRMEM", "LUA_ERRERR"]), no_foreign, no_foreign, no_foreign)))).
:- type_representation(index, is_eqv_to(int)).
:- type_representation(ls, is_eqv_to(luaMR.lua_state)).
:- type_representation(lua_error, is_word_aligned_ptr).
:- type_representation(lua_type, du_repn(enum("none", "nil_type", ["number_type", "boolean_type", "string_type", "lightuserdata_type", "function_type", "table_type", "thread_type", "userdata_type"],  c_j_cs_e(foreign_enum(["LUA_TNONE", "LUA_TNIL", "LUA_TNUMBER", "LUA_TBOOLEAN", "LUA_TSTRING", "LUA_TLIGHTUSERDATA", "LUA_TFUNCTION", "LUA_TTABLE", "LUA_TTHREAD", "LUA_TUSERDATA"]), no_foreign, no_foreign, no_foreign)))).
:- type_representation(mr_func, is_eqv_to((impure ((func luaMR.lua) = int)))).
:- type_representation(nil, du_repn(direct_dummy("nil",  no_c_j_cs_e))).
:- type_representation(values, is_eqv_to(list.list(luaMR.value))).
:- type_representation(vars, is_eqv_to(list.list(luaMR.var))).
:- implementation.
:- pragma foreign_import_module("C", luaMR).
:- pragma foreign_import_module("C", (luaMR.api)).
:- pragma foreign_import_module("C", (luaMR.state)).
:- pragma foreign_type(c, c_function, "lua_CFunction").
:- type index == int.
:- pragma foreign_type(c, lua, "lua_State *", [can_pass_as_mercury_type]).
:- pragma foreign_type(c, lua_state, "luaMR_lua_state *").
:- pragma foreign_type(c, ref, "luaMR_Ref", [can_pass_as_mercury_type]).
